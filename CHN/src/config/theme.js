/**
 *  File Name   : theme.js
 *  Author      : Pradeep Yadav
 *  Description : Theme Action Definitions 
 *  Version     : 1.0
 *  Package     : Theme Components
 *  Last update : 1 March 2022
 */
 import {
	Dimensions,
	Platform,
	BackAndroid,
	DeviceEventEmitter,
	LayoutAnimation,
    StatusBar,
	Alert
} from 'react-native';
import { getStoreData, googleApiKey, storeData } from '../api/apiAction';

import Geocoder from 'react-native-geocoding';
// import PushNotification from 'react-native-push-notification';
let dimObj = {};
let { height, width } = Dimensions.get('window');
const localStorage = {};
const _IOS = Platform.OS === 'ios' ? true : false;
const statusBarHeight = ()=> (_IOS ? 0 : StatusBar.currentHeight);
const base_unit = 16;

const textColor = {
	borderDefault: '#3f5873',
	borderSuccess: '#1ab394',
	borderPrimary: '#22aadd',
	borderInfo: '#55c3e4',
	borderWarning: '#f0ad4e',
	borderDanger: '#D64937',
	borderCorrect: '#55ad1f',
	borderIncorrect: '#af2517',
	btnDefault: '#fff',
	btnSuccess: '#fff',
	btnPrimary: '#fff',
	btnInfo: '#fff',
	btnWarning: '#fff',
	btnDanger: '#fff',
	btnGray: '#fff',
	basic: '#000'
};

const uiTheme = {
	default: {
		theme: 'default',
		fontFamily: 'arial',
		fontSize: { heading: 18, title: 17, content: 16, subContent: 14, },
		fontScale: { maxScale: 7, minScale: 40 },
		body: { bgColor: '#fff', color: '#000', child: '#fff' },
		bgColor: { heading: '#34485E', title: '#fff', content: '#fff' },
		color: { 
			heading: '#000', 
			title: '#34485E', 
			content: '#000',
			navBgColor: '#3f5873',
			topBar: '#34485E',
			navColor: '#fff',
			navSelected: '#2d3f52',
			navBorder: '#6b8bae', 	
			childColor: '#444',
			dangerColor: '#b0281a',
			warningColor: '#faebcc',
			infoColor: '#22b1dd', 
		},
		border: { 
			heading: '#34485E', 
			title: '#34485E', 
			content: '#34485E', 
			borderColor: '#6b8bae', 
		},
		fade: {
			fadeBg: '#ced8e4',
			fadeBgText: '',
			fadeColor: '#676767',
			fadeBorder: '#8ca5c0',
			fadeBorderSet: '#3f5873',
		},
		shadow: { 
			shadowBg: '',
			shadowColor: '',
			shadowBorder: '',
		},
		panel: {
			panelHeader: '#6b8bae',
			panelBorder: '#6b8bae',
			panelBody: '#fff',
			panelText: '#000',
			panelHeading: '#000',
		},
	},
};

let customTheme = uiTheme.default;
export function themePanel() {
	return {
		notifyConfig: function () {
			PushNotification.configure({

				// (optional) Called when Token is generated (iOS and Android)
				onRegister: function (token) {
					console.log('TOKEN:', token);
				},

				// (required) Called when a remote or local notification is opened or received
				onNotification: function (notification) {
					console.log('NOTIFICATION:', notification);
				},

				// ANDROID ONLY: GCM Sender ID (optional - not required for local notifications, but is need to receive remote push notifications)
				senderID: "YOUR GCM SENDER ID",

				// IOS ONLY (optional): default: all - Permissions to register.
				permissions: {
					alert: true,
					badge: true,
					sound: true
				},

				// Should the initial notification be popped automatically
				// default: true
				popInitialNotification: true,

				/**
				 * (optional) default: true
				* - Specified if permissions (ios) and token (android and ios) will requested or not,
				* - if not, you must call PushNotificationsHandler.requestPermissions() later
				*/
				requestPermissions: true,
			});
		},

		notifyByTime: function (res) {
			PushNotification.localNotificationSchedule(res);
		},

		notify: function (res) {
			PushNotification.localNotification(res);
			/**
			 * Android Only Properties 
			 * id: '0', // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
			 * ticker: "My Notification Ticker", // (optional)
			 * autoCancel: true, // (optional) default: true
			 * largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
			 * smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
			 * bigText: "My big text that will be shown when notification is expanded", // (optional) default: "message" prop
			 * subText: "This is a subText", // (optional) default: none
			 * color: "red", // (optional) default: system default
			 * vibrate: true, // (optional) default: true
			 * vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
			 * tag: 'some_tag', // (optional) add tag to message
			 * group: "group", // (optional) add group to message
			 * ongoing: false, // (optional) set whether this is an "ongoing" notification
			 */

			/* iOS only properties 
			alertAction: // (optional) default: view
			category: // (optional) default: null
			userInfo: // (optional) default: null (object containing additional notification data)
			*/

			/**
			 * iOS and Android properties 
			 * title: "My Notification Title", // (optional, for iOS this is only used in apple watch, the title will be the app name on other iOS devices)
			 * message: "My Notification Message", // (required)
			 * playSound: false, // (optional) default: true
			 * soundName: 'default', // (optional) Sound to play when the notification is shown. Value of 'default' plays the default sound. It can be set to a custom sound such as 'android.resource://com.xyz/raw/my_sound'. It will look for the 'my_sound' audio file in 'res/raw' directory and play it. default: 'default' (default sound is played)
			 * number: '10', // (optional) Valid 32 bit integer specified as string. default: none (Cannot be zero)
			 * repeatType: 'day', // (Android only) Repeating interval. Could be one of `week`, `day`, `hour`, `minute, `time`. If specified as time, it should be accompanied by one more parameter 'repeatTime` which should the number of milliseconds between each interval
			 * actions: '["Yes", "No"]',  // (Android only) See the doc for notification actions to know more
			 */
		},

		notifyHandler: function (data) {
			PushNotification.registerNotificationActions(['Accept', 'Reject', 'Yes', 'No']);
			DeviceEventEmitter.addListener('notificationActionReceived', function (action) {
				console.log('Notification action received: ' + action);
				const info = JSON.parse(action.dataJSON);
				if (info.action == 'Accept') {
					// Do work pertaining to Accept action here
					if (data.accept) {
						data.accept();
					}

				} else if (info.action == 'Reject') {
					// Do work pertaining to Reject action here
					if (data.reject) {
						data.reject();
					}

				}
				// Add all the required actions handlers
			});
		},

		cancelNotify: function (res) {
			// In res there should be notification id ex : { id : '123' }
			PushNotification.cancelLocalNotifications(res);
		},

		cancelAllNotify: function (res) {
			PushNotification.cancelAllLocalNotifications();
		},

	};
}

export function themeAction() {
	return {
		initGeoCoading: function() {
			Geocoder.init(googleApiKey);
		},
		geoFrom: function(cord) {
			return Geocoder.from(cord);
		},
		createError: function(res="Data not found", errKey = "reqInfo") {
			let _err = res?.error || res?.message || res;
			if (typeof _err == "string") {
				let tempKey =  (typeof res == "object") ? (res.error || res.message) : res;
				_err = {[errKey]: [tempKey]};
			}

			return _err;
		},
		getError: function(errObj) {
			if (typeof errObj == "object") {
				let result = "";
				for (let key in errObj) {
					result += errObj[key][0] + "\n";
				}
				return result;
			} else {
				return errObj;
			}
		},
		logError: function(origin, err) {
			console.log({origin, err});
		},
		setDigitStr: function (num) {
			if (num < 10) {
				return `0${num}`;
			}
			return num;
		},
		ask: function(data) {
			Alert.alert(
				data.title,
				data.msg,
				[
					{
						text: "OK",
						onPress: data.onOk,
						style: "ok",
					},
					{
						text: "Cancel",
						onPress: data.onCancel,
						style: "cancel",
					},
				],
				{
				  cancelable: true,
				  onDismiss: data.onDismiss || data.onCancel,
				}
			);
		},
		mergeArray: function(oldArray, newData) {
			if (!oldArray && !newData) {
				return [];
			}
			return Array.isArray(newData) ? [ ...oldArray, ...newData] : [...oldArray, newData];
		},
		getDataIndex: function(list, selected) {
			if (list && selected != null) {
				let result = list.findIndex( (x) => x.data == selected);
				return result == -1 ? 0 : result;
			} else {
				return false;
			}
		},
		updateDim : function (_width,_height){
			height = _height;
			width = _width;
		},
		triggerDimEvent: function(event) {
			for (let i in dimObj) {
				dimObj[i](event);
			}
		},
		dimOn: function(inf){
			dimObj[inf.onChange] = inf.onChange;
			Dimensions.addEventListener('change', inf.onChange);
			return inf.onChange;
		},
		dimOff: function(handler) {
			console.log("Dim off triggered");
			delete dimObj[handler];
			Dimensions.removeEventListener("change", handler);
		},
		isValid: function (data, type) {
			if (data && data != "undefined" && data != undefined && data != "" && data != null) {
				return type ? (typeof data == type ? true : false) : true;
			} else {
				return false;
			}
		},
		empty: function (data) {
			let result;
			if (data && data != "undefined" && data != undefined && data != "" && data != null) {
				if (typeof data == "object") {
					if (Array.isArray(data) && !data.length) {
						result = true;
					} else if (!Object.keys(data).length) {
						result = true;
					} else {
						result = false;
					}
				} else {
					result = false;
				}
			} else {
				result = true;
			}
			return result;
		},
		array_flip: function(trans) {
			let tmp_ar = {};
			for (let key in trans ) {
				if (trans.hasOwnProperty(key)) {
					tmp_ar[trans[key]] = key;
				}
			}
			return tmp_ar;
		},
		filterObjKeys: function (obj, keys = '') {
			let retObj = {};
			keys = keys.split(',');
			for (let key in obj) {
				retObj[key] = {};
				if (keys.length == 1) {
					retObj[key] = obj[key][keys[0]];
				} else {
					for (let i of keys) {
						retObj[key][i] = obj[key][i];
					}
				}
			}
			return retObj;
		},
		setData: function(arg, val) {
            localStorage[arg] = val;
			return localStorage[arg];
		},
		getData: function(arg) {
			return localStorage[arg];
		},
		animate: function(obj, type) {
			if (['easeInEaseOut', "linear", "spring"].includes(type)) {
				LayoutAnimation.configureNext(LayoutAnimation.Presets[type]);
			} else if (['scaleX', "scaleY", "scaleXY"].includes(type)) {
				LayoutAnimation.configureNext(LayoutAnimation.create(
					300,
					LayoutAnimation.Types.linear,
					LayoutAnimation.Properties[type],)
				);
			} else {
				LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
			}
			if (this.setState) {
				this.setState(obj);
			}
		},
		jsonToFormData(obj) {
	        let formData = new FormData();
	        for (let key in obj) {
	            formData.append(key, obj[key]);
	        }
	        return formData;
	    },

		accessKey: function(newToken) {
			return new Promise((resolve)=> {
				if (newToken) {
					localStorage['accessKey'] = newToken;
					storeData("accessKey", newToken);
					resolve(newToken);
				} else if (localStorage['accessKey']) {
					resolve(localStorage['accessKey']);
				} else {
					getStoreData('accessKey').then((res)=> {
						localStorage['accessKey'] = res;
						resolve(res);
					})
				}
			});
		},
		checkBack: function (action) {
			BackAndroid.addEventListener('hardwareBackPress', action);
		},
		clearBack: function () {
			BackAndroid.removeEventListener('hardwareBackPress');
		},
		deviceInfo: function (status, send = function () { }) {
			Orientation && Orientation.getOrientation((err, orientation) => {
				let inf = {
					height: height,
					width: width,
					type: Platform.OS,
					view: orientation,
					ios: _IOS,
				};
				send(inf);	
			});
		},
		lockToPortrait: function () {
			Orientation.lockToPortrait();
		},
		lockToLandscape: function () {
			Orientation.lockToLandscape();
		},
		unlockAll: function () {
			Orientation.unlockAllOrientations();
		},
		onStartApp: function () {
            return new Promise((resolve, reject)=>{
                Orientation.getOrientation((err, orientation) => {
                    if (width > height) {
                        resolve(true);
                    } else {
                        resolve(false);
                    }
                });
            })
		},
		layout: function (send = function () { }) {
			Orientation.getOrientation((err, orientation) => {
				send(orientation);
			});
		},

		ios: _IOS,
		type: Platform.OS,
		width: ()=> Dimensions.get('window').width,
		statusBarHeight,
		height: ()=> Dimensions.get('window').height - statusBarHeight(),
		display: function (attr) {
			Orientation && Orientation.addOrientationListener(attr.onChange);
		},
		displayOff: function (attr) {
			Orientation && Orientation.removeOrientationListener(attr.onChange);
		},

		setZindex: function (n) {
			return {
				zIndex: Number(n),
			};
		},
		setBg: function (c) {
			return {
				backgroundColor: c,
			};
		},
		setOpacity: function (n) {
			return {
				opacity: Number(n),
			};
		},
		getFontSize: function (inf) {
			let props = inf['props'];
			let minScale = (inf['minScale'] / 100);
			let maxScale = (inf['maxScale'] / 100);
			let _width = inf['width'];
			let _height = inf['height'];
			let size;

			if (props.fontSize) {
				size = props.fontSize;
			} else if (_height < 35) {
				let dim = (_height) * .5;
				size = dim;
			} else if (_height < 100) {
				let dim = (_height) * minScale;
				size = dim;
			} else {
				let dim = (_width) * maxScale;
				size = dim;
			}
			return +scale(size);
		},

		setFont: function (n) {
			return {
				fontSize: +scale(n),
			};
		},

		getFont : function (n) {
			return +scale(n);
		},
		setThemeFont: function (n, type, measureType) {
			return {
				fontSize: getMeasureFontSize(n, type, measureType),
			};
		},
		getThemeFont: function (n, type, measureType) {
			return getMeasureFontSize(n, type, measureType);
		},
		setFontFamily: function (family) {
			let fm = (customTheme.theme != 'disable') ? (customTheme.fontFamily || family) : family;
			return  {
				fontFamily: fm,
			};
		},
		setThemeBorder: function (n, borderColor, type) {
			return {
				borderWidth: Number(n),
				borderColor: getBorderColor(borderColor, type),
			};
		},
		getThemeBorder: function (borderColor, type) {
			return getBorderColor(borderColor, type);
		},
		setThemeColor: function (inf, type) {
			return {
				color: getColor(inf, type),
			};
		},
		getThemeColor: function (inf, type) {
			return getColor(inf, type);
		},

		setThemeBg: function (inf, type) {
			return {
				backgroundColor: getBackground(inf, type),
			};
		},
		getThemeBg: function (inf, type) {
			return getBackground(inf, type);
		},
		convertRatio: function (r) {
			return scale(r);
		},
		setFontWeight: function (n) {
			return {
				fontWeight: n,
			};
		},
		getRatio : function (num) {
			return scale(num);	
		},
		getThemeTextColor: function () {
			return textColor;
		},
		setColorTheme: function (themeName) {
			return {
				color: textColor[themeName],
			};
		},
		setColor: function (col) {
			return {
				color: col,
			};
		},
		getRadius: function (size) {
			return (size / 2);
		},
		setRound: function (size) {
			return {
				height: +size,
				width: +size,
				borderRadius: +(size / 2),
			};
		},
		setRadius: function (size) {
			return {
				borderRadius: +size,
			};
		},
		setRadiusOn: function (size, place) {
			switch(place) {
				case 'topLeft': return ({ borderTopLeftRadius: size, });
				case 'topRight': return ({ borderTopRightRadius: size });
				case 'bottomLeft': return ({ borderBottomLeftRadius: size, });
				case 'bottomRight': return ({ borderBottomRightRadius: size, });
				case 'topStart': return ({ borderTopStartRadius: size, });
				case 'bottomStart': return ({ borderBottomStartRadius: size, });
				case 'topEnd': return ({ borderTopEndRadius: size, });
				case 'bottomEnd': return ({ borderBottomEndRadius: size, });
				default: return ({borderRadius: size, });
			}
		},
		setRadiusAll: function (topL, topR, bottomL, bottomR) {
			return {
				borderTopLeftRadius: Number(topL),
				borderTopRightRadius: Number(topR),
				borderBottomLeftRadius: Number(bottomL),
				borderBottomRightRadius: Number(bottomR),
			};
		},
		setMargin: function (top, left, bottom, right, isPercent) {
			if (isPercent) {
				return {
					marginTop: `${(top || 0)}%`,
					marginLeft: `${(left || 0)}%`,
					marginRight: `${(right || 0)}%`,
					marginBottom: `${(bottom || 0)}%`,
				};
			} else {
				return {
					marginTop: Number(top || 0),
					marginLeft: Number(left || 0),
					marginRight: Number(right || 0),
					marginBottom: Number(bottom || 0)
				};
			}
			
		},
		setMarginAll: function (n, isPercent) {
			return {
				margin: isPercent ? `${n}%` : n,
			};
		},
		setMarginTop: function (n, isPercent) {
			return {
				marginTop: isPercent ? `${n}%` : n,
			};
		},
		setMarginLeft: function (n, isPercent) {
			return {
				marginLeft: isPercent ? `${n}%` : n,
			};
		},
		setMarginBottom: function (n, isPercent) {
			return {
				marginBottom: isPercent ? `${n}%` : n,
			};
		},
		setMarginRight: function (n, isPercent) {
			return {
				marginRight: isPercent ? `${n}%` : n,
			};
		},
		setPadding: function (top = 0, left = 0, bottom = 0, right = 0, isPercent = false) {
			return {
				paddingTop: isPercent ? `${top}%` : top,
				paddingLeft: isPercent ? `${left}%` : left,
				paddingRight: isPercent ? `${right}%` : right,
				paddingBottom: isPercent ? `${bottom}%` : bottom,
			};
		},

		setPaddingAll: function (n, isPercent) {
			return {
				padding: isPercent ? `${n}%` : n,
			};
		},

		setPaddingTop: function (n, isPercent) {
			return {
				paddingTop: isPercent ? `${n}%` : n,
			};
		},

		setPaddingLeft: function (n, isPercent) {
			return {
				paddingLeft: isPercent ? `${n}%` : n,
			};
		},

		setPaddingRight: function (n, isPercent) {
			return {
				paddingRight: isPercent ? `${n}%` : n,
			};
		},

		setPaddingBottom: function (n, isPercent) {
			return {
				paddingBottom: isPercent ? `${n}%` : n,
			};
		},

		setVmargin: function (n, isPercent) {
			return {
				marginVertical: isPercent ? `${n}%` : n,
			};
		},

		setHmargin: function (n,isPercent) {
			return {
				marginHorizontal: isPercent ? `${n}%` : n,
			};
		},

		setHpadding: function (n, isPercent) {
			return {
				paddingHorizontal: isPercent ? `${n}%` : n,
			};
		},

		setVpadding: function (n, isPercent) {
			return {
				paddingVertical: isPercent ? `${n}%` : n,
			};
		},

		setBorder: function (n, color, type) {
			return {
				borderWidth: n,
				borderColor: getBorderColor(color, type),
			};
		},
		setAllBorder: function (n, color, type) {
			return {
				borderLeftWidth: n,
				borderLeftColor: getBorderColor(color, type),
				borderTopWidth: n,
				borderTopColor: getBorderColor(color, type),
				borderRightWidth: n,
				borderRightColor: getBorderColor(color, type),
				borderBottomWidth: n,
				borderBottomColor: getBorderColor(color, type),
			};
		},
		setBorderTop: function (n, color, type) {
			return {
				borderTopWidth: n,
				borderTopColor: getBorderColor(color, type),
			};
		},

		setBorderLeft: function (n, color, type) {
			return {
				borderLeftWidth: n,
				borderLeftColor: getBorderColor(color, type),
			};
		},

		setBorderRight: function (n, color, type) {
			return {
				borderRightWidth: n,
				borderRightColor: getBorderColor(color, type),
			};
		},

		setBorderBottom: function (n, color, type) {
			return {
				borderBottomWidth: n,
				borderBottomColor: getBorderColor(color, type),
			};
		},
		setScreen: function (_width, _height, isPercent) {
			return {
				width: isPercent ? _width + '%' : (_width || width),
				height: isPercent ? _height + '%' : (_height || height),
			}
		},
		setWidth: function (n, isPercent) {
			return {
				width: isPercent ? n + '%' : (n || width),
			};
		},

		setHeight: function (n, isPercent) {
			return {
				height: isPercent ? n + '%' : (n || height),
			};
		},

		setAuto: function(type) {
			switch (type) {
				case 'height': return { height : 'auto' };
				case 'width': return { width: 'auto' };
				default: return { width: '100%', height : 'auto' };
			}

		},

		setHeightRatio: function (n) {
			return {
				height: n
			};
		},

		setMinMaxHeight: function (min, max) {
			return {
				minHeight: min,
				maxHeight: max,
			};
		},

		setMinMaxWidth: function (min, max) {
			return {
				minWidth: min,
				maxWidth: max,
			};
		},

		setMinWidth: function (n) {
			return {
				minWidth: n,
			};
		},

		setMinHeight: function (n) {
			return {
				minHeight: n,
			};
		},

		setMaxWidth: function (n) {
			return {
				maxWidth: n,
			};
		},

		setMaxHeight: function (n) {
			return {
				maxHeight: n,
			};
		},

		setFlex: function (_value) {
			return {
				flex: _value
			};
		},

		setTop: function (top, isPercent) {
			return {
				top: isPercent ? top + '%' : Number(top),
			};
		},

		setLeft: function (left, isPercent) {
			return {
				left: isPercent ? left + '%' : Number(left),
			};
		},

		setRight: function (right, isPercent) {
			return {
				right: isPercent ? right + '%' : Number(right),
			};
		},

		setBottom: function (bottom, isPercent) {
			return {
				bottom: isPercent ? bottom + '%' : Number(bottom),
			};
		},

		setPosition: function (top, left, isPercent) {
			return {
				top: isPercent ? top + '%' : Number(top),
				left: isPercent ? left + '%' : Number(left),
			};
		},

		setLineHeight: function (n) {
			return {
				lineHeight: n,
			};
		},

		setCenter: function (type) {
			let css;
			switch (type) {
				case 'v': css = { alignItems: 'center' };
					break;
				case 'h': css = { justifyContent: 'center' };
					break;
				case 'self': css = { alignSelf: 'center' };
					break;
				default: css = { alignItems: 'center', justifyContent: 'center' };
					break;
			};
			return css;
		},

		setItem: function (type) {
			let css;
			switch (type) {
				case 'hStart': css = { alignItems: 'flex-start' };
					break;
				case 'hEnd': css = { alignItems: 'flex-end' };
					break;
				case 'vCenter': css = { alignItems: 'center' };
					break;
				case 'hStretch': css = { alignItems: 'stretch' };
					break;
				case 'vStart': css = { justifyContent: 'flex-start' };
					break;
				case 'vEnd': css = { justifyContent: 'flex-end' };
					break;
				case 'vCenter': css = { justifyContent: 'center' };
					break;
				case 'vGap': css = { justifyContent: 'space-between' };
					break;
				case 'vAround': css = { justifyContent: 'space-around' };
					break;
				case 'selfStart': css = { alignSelf: 'flex-start' };
					break;
				case 'selfEnd': css = { alignSelf: 'flext-end' };
					break;
				case 'selfCenter': css = { alignSelf: 'center' };
					break;
				case 'selfStretch': css = { alignSelf: 'stretch' };
					break;
				default: css = { alignItems: 'center', justifyContent: 'center' };
					break;
			};
			return css;
		},

		setTextAlign: function (type) {
			// type - 'auto', 'top', 'bottom', 'center', 'justify'
			return ({
				textAlign: type,
			})
		},

		charSpace: function (num) {
			return ({
				letterSpacing: +num,
			});
		},
	};
}

function getBorderColor(borderColor, type) {
	let colorCode = borderColor;
	if (customTheme.theme && customTheme.theme != 'disable') {
		try {
			switch (type) {
				case 'content': colorCode = customTheme.border.content || borderColor;
					break;
				case 'heading': colorCode = customTheme.border.heading || borderColor;
					break;
				case 'title': colorCode = customTheme.border.title || borderColor;
					break;
				case 'navBorder': colorCode = customTheme.color.navBorder || borderColor;
					break;
				case 'border': colorCode = customTheme.border.borderColor || borderColor;
					break;
				case 'navBg': colorCode = customTheme.color.navBgColor || borderColor;
					break;
				case 'navTitle': colorCode = customTheme.color.topBar || borderColor;
					break;
				case 'fade': colorCode = customTheme.fade.fadeBorder || borderColor;
					break;
				case 'shadow': colorCode = customTheme.shadow.shadowBorder || inf;
					break;
				case 'panelHeader': colorCode = customTheme.panel.panelHeader || inf;
					break;
				case 'panelBorder': colorCode = customTheme.panel.panelBorder || inf;
					break;
				default: colorCode = borderColor;
					break;
			}
		} catch (e) {
			colorCode = borderColor;
		}
	}
	return colorCode;
}

function getBackground(inf, type) {
	let colorCode = inf;
	if (customTheme.theme && customTheme.theme != 'disable') {
		try {
			switch (type) {
				case 'content': colorCode = customTheme.bgColor.content || inf;
					break;
				case 'heading': colorCode = customTheme.bgColor.heading || inf;
					break;
				case 'title': colorCode = customTheme.bgColor.title || inf;
					break;
				case 'body': colorCode = customTheme.body.bgColor || inf;
					break;
				case 'navBg': colorCode = customTheme.color.navBgColor || inf;
					break;
				case 'navTopBg': colorCode = customTheme.color.topBar || inf;
					break;
				case 'navSelected': colorCode = customTheme.color.navSelected || inf;
					break;
				case 'child': colorCode = customTheme.body.child || inf;
					break;
				case 'fade': colorCode = customTheme.fade.fadeBg || inf;
					break;
				case 'shadow': colorCode = customTheme.shadow.shadowBg || inf;
					break;
				case 'panelHeader': colorCode = customTheme.panel.panelHeader || inf;
					break;
				case 'panelBody': colorCode = customTheme.panel.panelBody || inf;
					break;
				default: colorCode = inf;
					break;
			}
		} catch (e) {
			colorCode = inf;
		}
	}
	return colorCode;
}

function getColor(inf, type) {
	let colorCode = inf;
	if (customTheme.theme && customTheme.theme != 'disable') {
		try {
			switch (type) {
				case 'content': colorCode = customTheme.color.content || inf;
					break;
				case 'heading': colorCode = customTheme.color.heading || inf;
					break;
				case 'title': colorCode = customTheme.color.title || inf;
					break;
				case 'body': colorCode = customTheme.body.color || inf;
					break;
				case 'navTitle': colorCode = customTheme.color.topBar || inf;
					break;
				case 'navBg': colorCode = customTheme.color.navBgColor || inf;
					break;
				case 'navSelected' : colorCode = customTheme.color.navSelected || inf;
					break;
				case 'navColor': colorCode = customTheme.color.navColor || inf;
					break;
				case 'childColor': colorCode = customTheme.color.childColor || inf;
					break;
				case 'fade': colorCode = customTheme.fade.fadeColor || inf;
					break;
				case 'fadeBg': colorCode = customTheme.fade.fadeBg || inf;
					break;
				case 'fadeBgText': colorCode = customTheme.fade.fadeBgText || inf;
					break;
				case 'shadow': colorCode = customTheme.shadow.shadowColor || inf;
					break;
				case 'fadeBorder': colorCode = customTheme.fade.fadeBorder || inf;
					break;
				case 'fadeBorderSet': colorCode = customTheme.fade.fadeBorderSet || inf;
					break;
				case 'info': colorCode = customTheme.color.infoColor || inf;
					break;
				case 'danger': colorCode = customTheme.color.dangerColor || inf;
					break;
				case 'warning': colorCode = customTheme.color.warningColor || inf;
					break;
				case 'panelBorder': colorCode = customTheme.panel.panelBorder || inf;
					break;
				case 'panelText': colorCode = customTheme.panel.panelText || inf;
					break;
				case 'panelHeading': colorCode = customTheme.panel.panelHeading || inf;
					break;
				default: colorCode = inf;
					break;
			}
		} catch (e) {
			colorCode = inf;
		}

	}
	return colorCode;
}

function getMeasureFontSize(n, type, measureType) {
	let size = n;
	let isTheme = (customTheme.fontSize && customTheme.theme != 'disable');
	if (typeof n == "string" || isTheme) {
		let fontType = typeof n == "string" ? n : type;
		try {
			switch (fontType) {
				case 'content': size = ( isTheme ? (customTheme.fontSize.content || 16) : 16);
					break;
				case 'subContent': size = (isTheme ? (customTheme.fontSize.subContent || 14) : 14);
					break;
				case 'heading': size = (isTheme ? (customTheme.fontSize.heading || 18) : 18);
					break;
				case 'title': size = (isTheme ? (customTheme.fontSize.title || 17) : 17);
					break;
				default: size = (16);
					break;
			}
		} catch (e) {
			console.log("Error in Font setting = ",e);
			size = 16;
		}

	}
	
	return scale(size);
}

function scale(value, type) {
    //const ratio = UI.ios ? ( width < 550 ? ( width < 430 ? ( width < 375 ? (width < 320 ? 0.75 : 0.875) : 1 ) : 1.125 ) : 1.25 ) : 1;
    //const em = (base_unit * ratio) * 1;
    //console.log(PixelRatio.getPixelSizeForLayoutSize(1), ratio);
    //return (value * ratio);
	return value;
}