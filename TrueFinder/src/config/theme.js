/**
 *  File Name   : theme.js
 *  Author      : Pradeep Yadav
 *  Description : Theme Action Definitions 
 *  Version     : 1.0
 *  Package     : Theme Components
 *  Last update : 1 March 2022
 */
 import {
	BackAndroid,
	DeviceEventEmitter,
	LayoutAnimation,
	Alert
} from 'react-native';
import { getStoreData, storeData } from '../api/apiAction';
const localStorage = {};

export function themePanel() {
	return {
		notifyConfig: function () {
			PushNotification.configure({

				// (optional) Called when Token is generated (iOS and Android)
				onRegister: function (token) {
					console.log('TOKEN:', token);
				},

				// (required) Called when a remote or local notification is opened or received
				onNotification: function (notification) {
					console.log('NOTIFICATION:', notification);
				},

				// ANDROID ONLY: GCM Sender ID (optional - not required for local notifications, but is need to receive remote push notifications)
				senderID: "YOUR GCM SENDER ID",

				// IOS ONLY (optional): default: all - Permissions to register.
				permissions: {
					alert: true,
					badge: true,
					sound: true
				},

				// Should the initial notification be popped automatically
				// default: true
				popInitialNotification: true,

				/**
				 * (optional) default: true
				* - Specified if permissions (ios) and token (android and ios) will requested or not,
				* - if not, you must call PushNotificationsHandler.requestPermissions() later
				*/
				requestPermissions: true,
			});
		},

		notifyByTime: function (res) {
			PushNotification.localNotificationSchedule(res);
		},

		notify: function (res) {
			PushNotification.localNotification(res);
			/**
			 * Android Only Properties 
			 * id: '0', // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
			 * ticker: "My Notification Ticker", // (optional)
			 * autoCancel: true, // (optional) default: true
			 * largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
			 * smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
			 * bigText: "My big text that will be shown when notification is expanded", // (optional) default: "message" prop
			 * subText: "This is a subText", // (optional) default: none
			 * color: "red", // (optional) default: system default
			 * vibrate: true, // (optional) default: true
			 * vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
			 * tag: 'some_tag', // (optional) add tag to message
			 * group: "group", // (optional) add group to message
			 * ongoing: false, // (optional) set whether this is an "ongoing" notification
			 */

			/* iOS only properties 
			alertAction: // (optional) default: view
			category: // (optional) default: null
			userInfo: // (optional) default: null (object containing additional notification data)
			*/

			/**
			 * iOS and Android properties 
			 * title: "My Notification Title", // (optional, for iOS this is only used in apple watch, the title will be the app name on other iOS devices)
			 * message: "My Notification Message", // (required)
			 * playSound: false, // (optional) default: true
			 * soundName: 'default', // (optional) Sound to play when the notification is shown. Value of 'default' plays the default sound. It can be set to a custom sound such as 'android.resource://com.xyz/raw/my_sound'. It will look for the 'my_sound' audio file in 'res/raw' directory and play it. default: 'default' (default sound is played)
			 * number: '10', // (optional) Valid 32 bit integer specified as string. default: none (Cannot be zero)
			 * repeatType: 'day', // (Android only) Repeating interval. Could be one of `week`, `day`, `hour`, `minute, `time`. If specified as time, it should be accompanied by one more parameter 'repeatTime` which should the number of milliseconds between each interval
			 * actions: '["Yes", "No"]',  // (Android only) See the doc for notification actions to know more
			 */
		},

		notifyHandler: function (data) {
			PushNotification.registerNotificationActions(['Accept', 'Reject', 'Yes', 'No']);
			DeviceEventEmitter.addListener('notificationActionReceived', function (action) {
				console.log('Notification action received: ' + action);
				const info = JSON.parse(action.dataJSON);
				if (info.action == 'Accept') {
					// Do work pertaining to Accept action here
					if (data.accept) {
						data.accept();
					}

				} else if (info.action == 'Reject') {
					// Do work pertaining to Reject action here
					if (data.reject) {
						data.reject();
					}

				}
				// Add all the required actions handlers
			});
		},

		cancelNotify: function (res) {
			// In res there should be notification id ex : { id : '123' }
			PushNotification.cancelLocalNotifications(res);
		},

		cancelAllNotify: function (res) {
			PushNotification.cancelAllLocalNotifications();
		},

	};
}

export function useUI() {
	return {
		createError: function(res="Data not found", errKey = "reqInfo") {
			let _err = res?.error || res?.message || res;
			if (typeof _err == "string") {
				let tempKey =  (typeof res == "object") ? (res.error || res.message) : res;
				_err = {[errKey]: [tempKey]};
			}

			return _err;
		},
		getError: function(errObj) {
			if (typeof errObj == "object") {
				let result = "";
				for (let key in errObj) {
					result += errObj[key][0] + "\n";
				}
				return result;
			} else {
				return errObj;
			}
		},
		log: function(...data) {
			console.log(data);
		},
		setDigitStr: function (num) {
			if (num < 10) {
				return `0${num}`;
			}
			return num;
		},
		ask: function(data) {
			Alert.alert(
				data.title,
				data.msg,
				[
					{
						text: "OK",
						onPress: data.onOk,
						style: "ok",
					},
					{
						text: "Cancel",
						onPress: data.onCancel,
						style: "cancel",
					},
				],
				{
				  cancelable: true,
				  onDismiss: data.onDismiss || data.onCancel,
				}
			);
		},
		mergeArray: function(oldArray, newData) {
			if (!oldArray && !newData) {
				return [];
			}
			return Array.isArray(newData) ? [ ...oldArray, ...newData] : [...oldArray, newData];
		},
		getDataIndex: function(list, selected) {
			if (list && selected != null) {
				let result = list.findIndex( (x) => x.data == selected);
				return result == -1 ? 0 : result;
			} else {
				return false;
			}
		},
		isValid: function (data, type) {
			if (data && data != "undefined" && data != undefined && data != "" && data != null) {
				return type ? (typeof data == type ? true : false) : true;
			} else {
				return false;
			}
		},
		empty: function (data) {
			let result;
			if (data && data != "undefined" && data != undefined && data != "" && data != null) {
				if (typeof data == "object") {
					if (Array.isArray(data) && !data.length) {
						result = true;
					} else if (!Object.keys(data).length) {
						result = true;
					} else {
						result = false;
					}
				} else {
					result = false;
				}
			} else {
				result = true;
			}
			return result;
		},
		array_flip: function(trans) {
			let tmp_ar = {};
			for (let key in trans ) {
				if (trans.hasOwnProperty(key)) {
					tmp_ar[trans[key]] = key;
				}
			}
			return tmp_ar;
		},
		filterObjKeys: function (obj, keys = '') {
			let retObj = {};
			keys = keys.split(',');
			for (let key in obj) {
				retObj[key] = {};
				if (keys.length == 1) {
					retObj[key] = obj[key][keys[0]];
				} else {
					for (let i of keys) {
						retObj[key][i] = obj[key][i];
					}
				}
			}
			return retObj;
		},
		setData: function(arg, val) {
            localStorage[arg] = val;
			return localStorage[arg];
		},
		getData: function(arg) {
			return localStorage[arg];
		},
		animate: function(obj, type) {
			if (['easeInEaseOut', "linear", "spring"].includes(type)) {
				LayoutAnimation.configureNext(LayoutAnimation.Presets[type]);
			} else if (['scaleX', "scaleY", "scaleXY"].includes(type)) {
				LayoutAnimation.configureNext(LayoutAnimation.create(
					300,
					LayoutAnimation.Types.linear,
					LayoutAnimation.Properties[type],)
				);
			} else {
				LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
			}
			if (this.setState) {
				this.setState(obj);
			}
		},
		jsonToFormData(obj) {
	        let formData = new FormData();
	        for (let key in obj) {
	            formData.append(key, obj[key]);
	        }
	        return formData;
	    },
		accessKey: function(newToken) {
			return new Promise((resolve)=> {
				if (newToken) {
					localStorage['accessKey'] = newToken;
					storeData("accessKey", newToken);
					resolve(newToken);
				} else if (localStorage['accessKey']) {
					resolve(localStorage['accessKey']);
				} else {
					getStoreData('accessKey').then((res)=> {
						localStorage['accessKey'] = res;
						resolve(res);
					})
				}
			});
		},
		checkBack: function (action) {
			BackAndroid.addEventListener('hardwareBackPress', action);
		},
		clearBack: function () {
			BackAndroid.removeEventListener('hardwareBackPress');
		},
	};
}
